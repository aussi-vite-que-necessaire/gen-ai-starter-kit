name: Deploy App

on:
  push:
    branches: ["main"]

jobs:
  # --- JOB 0 : QUALITY GATE ---
  quality:
    uses: ./.github/workflows/quality.yml

  # --- JOB 1 : CONSTRUCTION DES IMAGES DOCKER (PARALL√àLE) ---
  build-images:
    needs: [quality]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [api, web]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Lowercase Repo Name
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

      - name: Create Web Env for Production
        if: matrix.service == 'web'
        run: |
          echo "VITE_API_URL=https://api.${{ vars.MAIN_DOMAIN }}" > ./apps/web/.env

      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push ${{ matrix.service }}
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./apps/${{ matrix.service }}/Dockerfile
          push: true
          tags: ghcr.io/${{ env.REPO_LOWER }}/${{ matrix.service }}:latest
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}

  # --- JOB 2 : COMPILATION DU CUSTOM NODE (PARALL√àLE) ---
  # On le sort du deploy pour qu'il tourne PENDANT que les images se construisent
  build-n8n-node:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 22
          cache: "npm"
          cache-dependency-path: apps/automation/custom-node/package-lock.json

      - name: Build Custom Node
        env:
          HUSKY: 0
        run: |
          # Install dependencies at root (handles workspaces)
          npm ci
          
          # Build custom node
          cd apps/automation/custom-node
          npm run build
          
          # Clean up for production artifact
          rm -rf node_modules
          npm ci --omit=dev

      # On sauvegarde le r√©sultat compil√© pour le job suivant
      - name: Upload Custom Node Artifact
        uses: actions/upload-artifact@v4
        with:
          name: n8n-custom-node
          path: apps/automation/custom-node/
          retention-days: 1

  # --- JOB 3 : D√âPLOIEMENT (Le chef d'orchestre) ---
  deploy:
    needs: [build-images, build-n8n-node] # üëà Attend que TOUT soit pr√™t
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Lowercase Repo Name
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

      # On r√©cup√®re le custom node compil√© par le job pr√©c√©dent
      - name: Download Custom Node Artifact
        uses: actions/download-artifact@v4
        with:
          name: n8n-custom-node
          path: apps/automation/custom-node

      # --- NETTOYAGE ---
      - name: Force Clean Remote Directory
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            mkdir -p apps/${{ vars.PROJECT_NAME }}
            cd apps/${{ vars.PROJECT_NAME }}
            docker run --rm -v "$(pwd):/clean" alpine rm -rf /clean/apps/automation

      # --- ENVOI ---
      - name: Copy Config to VPS
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "docker-compose.yml,apps/automation/"
          target: "apps/${{ vars.PROJECT_NAME }}"

      # --- SSH & SEED ---
      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          envs: DB_PASSWORD
          script: |
            export DB_PASSWORD=$DB_PASSWORD
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker image prune -f

            PROJECT_DB_APP="${{ vars.PROJECT_NAME }}_app"
            PROJECT_DB_N8N="${{ vars.PROJECT_NAME }}_n8n"
            export DATABASE_URL="postgresql://admin_postgres:$DB_PASSWORD@database-central:5432/$PROJECT_DB_APP?schema=public"

            cd ~/apps/${{ vars.PROJECT_NAME }}

            # --- A. BASES ---
            echo "üêò Provisioning Database..."
            docker run --rm --network web_network \
              -e PGPASSWORD=$DB_PASSWORD \
              postgres:16-alpine \
              sh -c "
                createdb -h database-central -U admin_postgres $PROJECT_DB_APP || true
                createdb -h database-central -U admin_postgres $PROJECT_DB_N8N || true
              "

            # --- B. ENV ---
            echo "üîß G√©n√©ration .env..."
            REPO_LOWER="${{ env.REPO_LOWER }}"
            cat <<EOF > .env
            IMAGE_NAME_API=ghcr.io/$REPO_LOWER/api:latest
            IMAGE_NAME_WEB=ghcr.io/$REPO_LOWER/web:latest
            IMAGE_NAME_N8N=n8nio/n8n:latest 
            POSTGRES_USER=admin_postgres
            DB_PASSWORD=$DB_PASSWORD
            POSTGRES_DB_APP=$PROJECT_DB_APP
            POSTGRES_DB_N8N=$PROJECT_DB_N8N
            PROJECT_NAME=${{ vars.PROJECT_NAME }}
            NODE_ENV=production
            PORT=3000
            DOMAIN_NAME_WEB=${{ vars.MAIN_DOMAIN }}
            DOMAIN_NAME_API=api.${{ vars.MAIN_DOMAIN }}
            DOMAIN_NAME_N8N=n8n.${{ vars.MAIN_DOMAIN }}
            FRONTEND_URL=https://${{ vars.MAIN_DOMAIN }}
            N8N_URL=https://n8n.${{ vars.MAIN_DOMAIN }}
            BETTER_AUTH_URL=https://api.${{ vars.MAIN_DOMAIN }}
            DATABASE_URL=$DATABASE_URL
            INTERNAL_API_SECRET=${{ secrets.INTERNAL_API_SECRET }}
            N8N_ENCRYPTION_KEY=${{ secrets.N8N_ENCRYPTION_KEY }}
            BETTER_AUTH_SECRET=${{ secrets.BETTER_AUTH_SECRET }}
            REDIS_HOST=redis
            REDIS_PORT=6379
            EOF
            chmod 600 .env

            # --- C. START ---
            echo "üì• Pull & Start..."
            docker compose pull
            docker compose up -d --remove-orphans

            # --- D. POST-DEPLOY ---
            echo "üì¶ Migrations API..."
            docker compose run --rm -e DATABASE_URL=$DATABASE_URL api npm run db:migrate

            echo "üì• Import N8N Workflows..."
            WORKFLOWS_DIR="apps/automation/workflows"

            # Attendre que n8n soit compl√®tement pr√™t (migrations termin√©es + healthcheck)
            echo "‚è≥ Attente que n8n soit pr√™t (healthcheck)..."
            MAX_WAIT=60
            WAITED=0
            while [ $WAITED -lt $MAX_WAIT ]; do
              if docker run --rm --network web_network curlimages/curl:latest \
                sh -c 'curl -s -f http://gen-ai-starter-kit-n8n-1:5678/healthz > /dev/null 2>&1'; then
                echo "‚úÖ n8n est pr√™t !"
                break
              fi
              echo "‚è≥ Attente... ($WAITED/$MAX_WAIT secondes)"
              sleep 5
              WAITED=$((WAITED + 5))
            done

            # Attendre encore un peu pour que les migrations soient vraiment termin√©es
            echo "‚è≥ Pause suppl√©mentaire pour finaliser les migrations..."
            sleep 10

            # Import des credentials en premier
            if [ -f "$WORKFLOWS_DIR/credentials.json" ]; then
              echo "üîë Import des credentials..."
              docker compose cp "$WORKFLOWS_DIR/credentials.json" n8n:/tmp/credentials.json
              docker compose exec -u node -T n8n n8n import:credentials --input=/tmp/credentials.json || echo "‚ö†Ô∏è Import credentials failed (peut √™tre normal si d√©j√† import√©)"
            fi

            # Import des workflows (ignorer les erreurs de webhooks qui sont normales)
            for file in "$WORKFLOWS_DIR"/*.json; do
              filename=$(basename "$file")
              if [ "$filename" != "credentials.json" ]; then
                echo "üìã Import du workflow: $filename"
                docker compose cp "$file" n8n:/tmp/workflow.json
                # Les erreurs "Could not find workflow" sont normales lors du premier import
                docker compose exec -u node -T n8n n8n import:workflow --input=/tmp/workflow.json 2>&1 | grep -v "Could not find workflow" || true
                sleep 2
              fi
            done

            echo "üîÑ Activation des workflows..."
            docker compose exec -u node -T n8n n8n update:workflow --all --active=true || echo "‚ö†Ô∏è Activation workflows failed (peut √™tre normal)"

            echo "üîÑ Red√©marrage de n8n pour activer les workflows..."
            docker compose restart n8n
            sleep 5

            echo "‚úÖ D√©ploiement termin√© !"
